{
  "version": 3,
  "sources": ["../../swr/dist/immutable/index.mjs", "../../swr-openapi/src/query-base.ts", "../../swr-openapi/src/immutable.ts", "../../swr-openapi/src/infinite.ts", "../../swr-openapi/src/mutate.ts", "../../swr-openapi/src/query.ts"],
  "sourcesContent": ["import useSWR from '../index/index.mjs';\nimport { withMiddleware } from '../_internal/index.mjs';\n\nconst immutable = (useSWRNext)=>(key, fetcher, config)=>{\n        // Always override all revalidate options.\n        config.revalidateOnFocus = false;\n        config.revalidateIfStale = false;\n        config.revalidateOnReconnect = false;\n        return useSWRNext(key, fetcher, config);\n    };\nconst useSWRImmutable = withMiddleware(useSWR, immutable);\n\nexport { useSWRImmutable as default, immutable };\n", "import type { Client } from \"openapi-fetch\";\nimport type { MediaType, PathsWithMethod, RequiredKeysOf } from \"openapi-typescript-helpers\";\nimport type { Fetcher, SWRHook } from \"swr\";\nimport type { TypesForGetRequest } from \"./types.js\";\nimport { useCallback, useDebugValue, useMemo } from \"react\";\n\n/**\n * @private\n */\nexport function configureBaseQueryHook(useHook: SWRHook) {\n  return function createQueryBaseHook<\n    Paths extends {},\n    IMediaType extends MediaType,\n    Prefix extends string,\n    FetcherError = never,\n  >(client: Client<Paths, IMediaType>, prefix: Prefix) {\n    return function useQuery<\n      Path extends PathsWithMethod<Paths, \"get\">,\n      R extends TypesForGetRequest<Paths, Path>,\n      Init extends R[\"Init\"],\n      Data extends R[\"Data\"],\n      Error extends R[\"Error\"] | FetcherError,\n      Config extends R[\"SWRConfig\"],\n    >(\n      path: Path,\n      ...[init, config]: RequiredKeysOf<Init> extends never ? [(Init | null)?, Config?] : [Init | null, Config?]\n    ) {\n      useDebugValue(`${prefix} - ${path as string}`);\n\n      const key = useMemo(() => (init !== null ? ([prefix, path, init] as const) : null), [prefix, path, init]);\n\n      type Key = typeof key;\n\n      // TODO: Lift up fetcher to and remove useCallback\n      const fetcher: Fetcher<Data, Key> = useCallback(\n        async ([_, path, init]) => {\n          // @ts-expect-error TODO: Improve internal init types\n          const res = await client.GET(path, init);\n          if (res.error) {\n            throw res.error;\n          }\n          return res.data as Data;\n        },\n        [client],\n      );\n\n      // @ts-expect-error TODO: Improve internal config types\n      return useHook<Data, Error, Key>(key, fetcher, config);\n    };\n  };\n}\n", "import useSWRImmutable from \"swr/immutable\";\nimport { configureBaseQueryHook } from \"./query-base.js\";\n\n/**\n * Produces a typed wrapper for [`useSWRImmutable`](https://swr.vercel.app/docs/revalidation.en-US#disable-automatic-revalidations).\n *\n * ```ts\n * import createClient from \"openapi-fetch\";\n * const client = createClient();\n *\n * const useImmutable = createImmutableHook(client, \"<unique-key>\");\n *\n * // Fetch the query\n * useImmutable(\"/pets\");\n *\n * // Skip the query\n * useImmutable(\"/pets\", null);\n *\n * // Fetch the query with parameters\n * useImmutable(\"/pets\", {\n *   params: { query: { limit: 10 } }\n * });\n *\n * // Fetch the query with parameters and SWR configuration\n * useImmutable(\n *   \"/pets\",\n *   { params: { query: { limit: 10 } } },\n *   { errorRetryCount: 2 },\n * );\n *\n * // Fetch the query with no parameters and SWR configuration\n * useImmutable(\n *   \"/pets\",\n *   {},\n *   { errorRetryCount: 2 },\n * );\n * ```\n */\nexport const createImmutableHook = configureBaseQueryHook(useSWRImmutable);\n", "import type { Client } from \"openapi-fetch\";\nimport type { MediaType, PathsWithMethod } from \"openapi-typescript-helpers\";\nimport useSWRInfinite, {\n  type SWRInfiniteConfiguration,\n  type SWRInfiniteFetcher,\n  type SWRInfiniteKeyLoader,\n} from \"swr/infinite\";\nimport type { TypesForGetRequest } from \"./types.js\";\nimport { useCallback, useDebugValue } from \"react\";\n\n/**\n * Produces a typed wrapper for [`useSWRInfinite`](https://swr.vercel.app/docs/pagination#useswrinfinite).\n *\n * ```ts\n * import createClient from \"openapi-fetch\";\n * const client = createClient();\n *\n * const useInfinite = createInfiniteHook(client, \"<unique-key>\");\n *\n * useInfinite(\"/pets\", (index, previousPage) => {\n *   if (previousPage && !previousPage.hasMore) {\n *     return null;\n *   }\n *\n *   return {\n *     params: {\n *       query: {\n *         limit: 10,\n *         offset: index * 10,\n *       },\n *     },\n *   };\n * });\n * ```\n */\nexport function createInfiniteHook<\n  Paths extends {},\n  IMediaType extends MediaType,\n  Prefix extends string,\n  FetcherError = never,\n>(client: Client<Paths, IMediaType>, prefix: Prefix) {\n  return function useInfinite<\n    Path extends PathsWithMethod<Paths, \"get\">,\n    R extends TypesForGetRequest<Paths, Path>,\n    Init extends R[\"Init\"],\n    Data extends R[\"Data\"],\n    Error extends R[\"Error\"] | FetcherError,\n    Config extends SWRInfiniteConfiguration<Data, Error>,\n  >(path: Path, getInit: SWRInfiniteKeyLoader<Data, Init | null>, config?: Config) {\n    type Key = [Prefix, Path, Init | undefined] | null;\n    type KeyLoader = SWRInfiniteKeyLoader<Data, Key>;\n\n    useDebugValue(`${prefix} - ${path as string}`);\n\n    const fetcher: SWRInfiniteFetcher<Data, KeyLoader> = useCallback(\n      async ([_, path, init]) => {\n        // @ts-expect-error TODO: Improve internal init types\n        const res = await client.GET(path, init);\n        if (res.error) {\n          throw res.error;\n        }\n        return res.data as Data;\n      },\n      [client],\n    );\n\n    const getKey: KeyLoader = (index, previousPageData) => {\n      const init = getInit(index, previousPageData);\n      if (init === null) {\n        return null;\n      }\n      const key: Key = [prefix, path, init];\n      return key;\n    };\n\n    return useSWRInfinite<Data, Error, KeyLoader>(getKey, fetcher, config);\n  };\n}\n", "import type { Client } from \"openapi-fetch\";\nimport type { MediaType, PathsWithMethod } from \"openapi-typescript-helpers\";\nimport { useCallback, useDebugValue } from \"react\";\nimport { type MutatorCallback, type MutatorOptions, useSWRConfig } from \"swr\";\nimport type { PartialDeep } from \"type-fest\";\nimport type { TypesForGetRequest } from \"./types.js\";\n\n// Types are loose here to support ecosystem utilities like `_.isMatch`\nexport type CompareFn = (init: any, partialInit: any) => boolean;\n\n/**\n * Produces a typed wrapper for [`useSWRConfig#mutate`](https://swr.vercel.app/docs/mutation).\n *\n * ```ts\n * import createClient from \"openapi-fetch\";\n * import { isMatch } from \"lodash\";\n *\n * const client = createClient();\n *\n * const useMutate = createMutateHook(client, \"<unique-key>\", isMatch);\n *\n * const mutate = useMutate();\n *\n * // Revalidate all keys matching this path\n * await mutate([\"/pets\"]);\n * await mutate([\"/pets\"], newData);\n * await mutate([\"/pets\"], undefined, { revalidate: true });\n *\n * // Revlidate all keys matching this path and this subset of options\n * await mutate(\n *   [\"/pets\", { query: { limit: 10 } }],\n *   newData,\n *   { revalidate: false }\n * );\n * ```\n */\nexport function createMutateHook<Paths extends {}, IMediaType extends MediaType>(\n  client: Client<Paths, IMediaType>,\n  prefix: string,\n  compare: CompareFn,\n) {\n  return function useMutate() {\n    const { mutate: swrMutate } = useSWRConfig();\n\n    useDebugValue(prefix);\n\n    return useCallback(\n      function mutate<\n        Path extends PathsWithMethod<Paths, \"get\">,\n        R extends TypesForGetRequest<Paths, Path>,\n        Init extends R[\"Init\"],\n      >(\n        [path, init]: [Path, PartialDeep<Init>?],\n        data?: R[\"Data\"] | Promise<R[\"Data\"]> | MutatorCallback<R[\"Data\"]>,\n        opts?: boolean | MutatorOptions<R[\"Data\"]>,\n      ) {\n        return swrMutate<R[\"Data\"], R[\"Data\"]>(\n          (key) => {\n            if (\n              // Must be array\n              !Array.isArray(key) ||\n              // Must have 2 or 3 elements (prefix, path, optional init)\n              ![2, 3].includes(key.length)\n            ) {\n              return false;\n            }\n\n            const [keyPrefix, keyPath, keyOptions] = key as unknown[];\n\n            return (\n              // Matching prefix\n              keyPrefix === prefix &&\n              // Matching path\n              keyPath === path &&\n              // Matching options\n              (init ? compare(keyOptions, init) : true)\n            );\n          },\n          data,\n          opts,\n        );\n      },\n      [swrMutate, prefix, compare],\n    );\n  };\n}\n", "import useSWR from \"swr\";\nimport { configureBaseQueryHook } from \"./query-base.js\";\n\n/**\n * Produces a typed wrapper for [`useSWR`](https://swr.vercel.app/docs/api).\n *\n * ```ts\n * import createClient from \"openapi-fetch\";\n *\n * const client = createClient();\n *\n * const useQuery = createQueryHook(client, \"<unique-key>\");\n *\n * // Fetch the query\n * useQuery(\"/pets\");\n *\n * // Skip the query\n * useQuery(\"/pets\", null);\n *\n * // Fetch the query with parameters\n * useQuery(\"/pets\", {\n *   params: { query: { limit: 10 } }\n * });\n *\n * // Fetch the query with parameters and SWR configuration\n * useQuery(\n *   \"/pets\",\n *   { params: { query: { limit: 10 } } },\n *   { errorRetryCount: 2 },\n * );\n *\n * // Fetch the query with no parameters and SWR configuration\n * useQuery(\n *   \"/pets\",\n *   {},\n *   { errorRetryCount: 2 },\n * );\n * ```\n */\nexport const createQueryHook = configureBaseQueryHook(useSWR);\n"],
  "mappings": ";;;;;;;;;;;;;;AAGA,IAAM,YAAY,CAAC,eAAa,CAAC,KAAK,SAAS,WAAS;AAEhD,SAAO,oBAAoB;AAC3B,SAAO,oBAAoB;AAC3B,SAAO,wBAAwB;AAC/B,SAAO,WAAW,KAAK,SAAS,MAAM;AAC1C;AACJ,IAAM,kBAAkB,eAAe,QAAQ,SAAS;A;;;ACDjD,SAAS,uBAAuB,SAAkB;AAChD,SAAA,SAAS,oBAKd,QAAmC,QAAgB;AACnD,WAAO,SAAS,SAQd,SACG,CAAC,MAAM,MAAM,GAChB;AACA,sCAAc,GAAG,MAAM,MAAM,IAAc,EAAE;AAE7C,YAAM,UAAM,sBAAQ,MAAO,SAAS,OAAQ,CAAC,QAAQ,MAAM,IAAI,IAAc,MAAO,CAAC,QAAQ,MAAM,IAAI,CAAC;AAKxG,YAAM,cAA8B;QAClC,OAAO,CAAC,GAAGA,OAAMC,KAAI,MAAM;AAEzB,gBAAM,MAAM,MAAM,OAAO,IAAID,OAAMC,KAAI;AACvC,cAAI,IAAI,OAAO;AACb,kBAAM,IAAI;UAAA;AAEZ,iBAAO,IAAI;QAAA;QAEb,CAAC,MAAM;MAAA;AAIF,aAAA,QAA0B,KAAK,SAAS,MAAM;IAAA;EACvD;AAEJ;ACZa,IAAA,sBAAsB,uBAAuB,eAAe;ACHzD,SAAA,mBAKd,QAAmC,QAAgB;AACnD,SAAO,SAAS,YAOd,MAAY,SAAkD,QAAiB;AAI/E,oCAAc,GAAG,MAAM,MAAM,IAAc,EAAE;AAE7C,UAAM,cAA+C;MACnD,OAAO,CAAC,GAAGD,OAAM,IAAI,MAAM;AAEzB,cAAM,MAAM,MAAM,OAAO,IAAIA,OAAM,IAAI;AACvC,YAAI,IAAI,OAAO;AACb,gBAAM,IAAI;QAAA;AAEZ,eAAO,IAAI;MAAA;MAEb,CAAC,MAAM;IAAA;AAGH,UAAA,SAAoB,CAAC,OAAO,qBAAqB;AAC/C,YAAA,OAAO,QAAQ,OAAO,gBAAgB;AAC5C,UAAI,SAAS,MAAM;AACV,eAAA;MAAA;AAET,YAAM,MAAW,CAAC,QAAQ,MAAM,IAAI;AAC7B,aAAA;IAAA;AAGF,WAAA,eAAuC,QAAQ,SAAS,MAAM;EAAA;AAEzE;ACzCgB,SAAA,iBACd,QACA,QACA,SACA;AACA,SAAO,SAAS,YAAY;AAC1B,UAAM,EAAE,QAAQ,UAAU,IAAI,aAAa;AAE3C,oCAAc,MAAM;AAEb,eAAA;MACL,SAAS,OAKP,CAAC,MAAM,IAAI,GACX,MACA,MACA;AACO,eAAA;UACL,CAAC,QAAQ;AACP;;cAEE,CAAC,MAAM,QAAQ,GAAG;cAElB,CAAC,CAAC,GAAG,CAAC,EAAE,SAAS,IAAI,MAAM;cAC3B;AACO,qBAAA;YAAA;AAGT,kBAAM,CAAC,WAAW,SAAS,UAAU,IAAI;AAEzC;;cAEE,cAAc;cAEd,YAAY;eAEX,OAAO,QAAQ,YAAY,IAAI,IAAI;;UAAA;UAGxC;UACA;QAAA;MACF;MAEF,CAAC,WAAW,QAAQ,OAAO;IAAA;EAC7B;AAEJ;AC9Ca,IAAA,kBAAkB,uBAAuB,MAAM;",
  "names": ["path", "init"]
}
